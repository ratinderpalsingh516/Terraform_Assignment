# Terraform Assignment
A Github repository for Terraform Assignment

## Problem Statement:
● Write Terraform script to create a custom VPC and deploy two EC2 VMs on AWS using Terraform.  
● The code should be broken into three different parts: 

    ○ Networking (define the VPC and all of its components)   
    ○ SSH-Key (dynamically create an SSH-key pair for connecting to VMs)  
    ○ EC2 (deploy a VM in the public subnet, and deploy another VM in a private subnet)
    ○ NGINX should be accessed for all the internet  
● Automate Terraform Deployment with Jenkins Pipelines  

## Solution:

### i. Custom VPC
This Terraform code creates a resource of type ```aws_vpc```, which is a virtual private cloud (VPC) in AWS. A VPC is a logically isolated network that we can use to launch our AWS resources.  
```
resource "aws_vpc" "custom_vpc" {
  cidr_block = "10.0.0.0/16"

  tags = {
    Name = "Custom VPC"
  }
}
```
### Snippet Explanation
1. The code assigns a name of *custom_vpc* to the resource, which is how we can refer to it in other parts of the code.  
2. The code sets the ```cidr_block``` attribute to *10.0.0.0/16*, which is the range of IP addresses that the VPC can use. 
3. The /16 notation means that the first 16 bits of the IP address are fixed, and the remaining 16 bits can vary. This gives us 65,536          possible IP addresses in the VPC.
4. The code also sets the tags attribute to a map of key-value pairs that we can use to label and identify the VPC. In this case, the code      sets the tag ```Name``` to *Custom VPC*.
### Output
![image](https://github.com/ratinderpalsingh516/Terraform_Assignment/assets/122514456/3e32a650-3b58-4fc3-891e-1a6d79a2b8a3)

### ii. Public Subnet
This Terraform code creates a resource of type ```aws_subnet```, which is a subnet in AWS. A subnet is a segment of a VPC that can contain your resources.
```
resource "aws_subnet" "public_subnet" {
  vpc_id                  = aws_vpc.custom_vpc.id
  cidr_block              = "10.0.1.0/24"
  availability_zone       = "us-east-1a"
  map_public_ip_on_launch = true

  tags = {
    Name = "Public Subnet"
  }
}
```
### Snippet Explanation
1. The code assigns a name of *public_subnet* to the resource, which is how we can refer to it in other parts of the code.
2. The code sets the ```vpc_id``` attribute to *aws_vpc.custom_vpc.id*, which is the ID of the VPC that the subnet belongs to. This ID is      automatically generated by Terraform when we create the VPC resource.
3. The code sets the ```cidr_block``` attribute to *10.0.1.0/24*, which is the range of IP addresses that the subnet can use. The /24          notation means that the first 24 bits of the IP address are fixed, and the remaining 8 bits can vary. This gives us 256 possible IP          addresses in the subnet.
4. The code sets the ```availability_zone``` attribute to *us-east-1a*, which is the name of the availability zone that the subnet is          located in.
5. The code sets the ```map_public_ip_on_launch``` attribute to *true*, which means that any instance launched in this subnet will              automatically get a public IP address that can be accessed from the internet.
6. The code also sets the ```tags``` attribute to a map of key-value pairs that we can use to label and identify the subnet. In this case,      the code sets the tag ```Name``` to *Public Subnet*.
### Output
<img width="826" alt="Screenshot 2023-06-05 at 2 55 40 PM" src="https://github.com/ratinderpalsingh516/Terraform_Assignment/assets/122514456/95ee24fb-0827-4d78-936c-494728a00453">

### iii. Private Subnet
This Terraform code creates a resource of type ```aws_subnet```, which is a subnet in AWS. A subnet is a segment of a VPC that can contain your resources.
```
resource "aws_subnet" "private_subnet" {
  vpc_id                  = aws_vpc.custom_vpc.id
  cidr_block              = "10.0.2.0/24"
  availability_zone       = "us-east-1b"

  tags = {
    Name = "Private Subnet"
  }
}
```
### Snippet Explanation
1. The code assigns a name of *private_subnet* to the resource, which is how we can refer to it in other parts of the code.
2. The code sets the ```vpc_id``` attribute to *aws_vpc.custom_vpc.id*, which is the ID of the VPC that the subnet belongs to. This ID is      automatically generated by Terraform when we create the VPC resource.
3. The code sets the ```cidr_block``` attribute to *10.0.2.0/24*, which is the range of IP addresses that the subnet can use. The /24          notation means that the first 24 bits of the IP address are fixed, and the remaining 8 bits can vary. This gives us 256 possible IP          addresses in the subnet.
4. The code sets the ```availability_zone``` attribute to *us-east-1b*, which is the name of the availability zone that the subnet is          located in. 
5. The code does not set the ```map_public_ip_on_launch``` attribute, which means that any instance launched in this subnet will not get a      public IP address by default. This makes this subnet private and inaccessible from the internet.
6. The code also sets the ```tags``` attribute to a map of key-value pairs that we can use to label and identify the subnet. In this case,      the code sets the tag ```Name``` to *Private Subnet*.
### Output
<img width="828" alt="Screenshot 2023-06-05 at 2 45 38 PM" src="https://github.com/ratinderpalsingh516/Terraform_Assignment/assets/122514456/5c1ab431-b19f-4303-80a8-40bb4b84212c">

### iv. SSH Key Pair
This Terraform code creates two resources: one of type ```tls_private_key``` and one of type ```aws_key_pair```.
```
resource "tls_private_key" "ssh_key" {
  algorithm = "RSA"
}

resource "aws_key_pair" "ssh_key_pair" {
  key_name   = "ssh-key"
  public_key = tls_private_key.ssh_key.public_key_openssh
}
```
### Snippet Explanation
1. The ```tls_private_key``` resource creates a private key for SSH access to the EC2 instances. 
2. The code assigns a name of *ssh_key* to the resource, which is how we can refer to it in other parts of the code. 
3. The code sets the ```algorithm``` attribute to *RSA*, which is the encryption algorithm used to generate the key.
4. The ```aws_key_pair``` resource creates a key pair in AWS using the private key generated by the ```tls_private_key``` resource. 
5. The code assigns a name of *ssh_key_pair* to the resource, which is how you can refer to it in other parts of the code. 
6. The code sets the ```key_name``` attribute to *ssh-key*, which is the name of the key pair in AWS. 
7. The code sets the ```public_key``` attribute to *tls_private_key.ssh_key.public_key_openssh*, which is the public key in OpenSSH format      that corresponds to the private key. The public key is automatically derived from the private key by Terraform.
### Output
![image](https://github.com/ratinderpalsingh516/Terraform_Assignment/assets/122514456/fe9e297f-3833-4892-b9d8-a994994c237c)
![image](https://github.com/ratinderpalsingh516/Terraform_Assignment/assets/122514456/ca393e3d-fd74-42a7-97fc-41a043d90c28)

### v. Public EC2 Instance
This Terraform code creates a resource of type aws_instance, which is an EC2 instance in AWS. An EC2 instance is a virtual machine that you can use to run your applications.
```
resource "aws_instance" "public_vm" {
  ami           = "ami-abc123"
  instance_type = "t2.micro"
  key_name      = aws_key_pair.ssh_key_pair.key_name
  subnet_id     = aws_subnet.public_subnet.id

  tags = {
    Name = "Public VM"
  }

  provisioner "remote-exec" {
    inline = [
      "sudo apt-get update",
      "sudo apt-get install -y nginx",
      "sudo systemctl start nginx"
    ]
  }
}
```
### Snippet Explanation
1. The code assigns a name of *public_vm* to the resource, which is how you can refer to it in other parts of the code.
2. The code sets the ```ami``` attribute to *ami-abc123*, which is the ID of the Amazon Machine Image (AMI) that the instance will use. An AMI is a template that contains the operating system and software configuration for the instance.
3. The code sets the ```instance_type``` attribute to *t2.micro*, which is the type of the instance. The instance type determines the CPU, memory, storage, and network capacity of the instance.
4. The code sets the ```key_name``` attribute to *aws_key_pair.ssh_key_pair.key_name*, which is the name of the key pair that the instance will use for SSH access. The key pair was created by the aws_key_pair resource.
5. The code sets the ```subnet_id``` attribute to *aws_subnet.public_subnet.id*, which is the ID of the subnet that the instance will be launched in. The subnet was created by the aws_subnet resource.
6. The code also sets the ```tags``` attribute to a map of key-value pairs that you can use to label and identify the instance. In this case, the code sets the tag ```Name``` to *Public VM*.
7. The code also uses a provisioner block to run some commands on the instance after it is created. The provisioner type is ```remote-exec```, which means that the commands will be executed remotely via SSH. The provisioner uses the ```inline``` argument to specify a list of commands to run. In this case, the commands are:  
```sudo apt-get update```: This updates the package lists for upgrades and new packages.  
```sudo apt-get install -y nginx```: This installs nginx, a web server, on the instance.  
```sudo systemctl start nginx```: This starts nginx on the instance.  
### Output
![image](https://github.com/ratinderpalsingh516/Terraform_Assignment/assets/122514456/907ce69f-45c1-473a-a5c6-8dea87cde251)

### vi. Private EC2 Instance
This Terraform code creates a resource of type aws_instance, which is an EC2 instance in AWS. An EC2 instance is a virtual machine that you can use to run your applications.
```
resource "aws_instance" "private_vm" {
  ami           = "ami-xyz789"
  instance_type = "t2.micro"
  key_name      = aws_key_pair.ssh_key_pair.key_name
  subnet_id     = aws_subnet.private_subnet.id

  tags = {
    Name = "Private VM"
  }

   provisioner "remote-exec" {
    inline = [
      "sudo apt-get update",
      "sudo apt-get install -y nginx",
      "sudo systemctl start nginx"
    ]
  }
}
```
### Snippet Explanation
1. The code assigns a name of *private_vm* to the resource, which is how you can refer to it in other parts of the code.
2. The code sets the ```ami``` attribute to *ami-xyz789*, which is the ID of the Amazon Machine Image (AMI) that the instance will use. An AMI is a template that contains the operating system and software configuration for the instance.
3. The code sets the ```instance_type``` attribute to *t2.micro*, which is the type of the instance. The instance type determines the CPU, memory, storage, and network capacity of the instance.
4. The code sets the ```key_name``` attribute to *aws_key_pair.ssh_key_pair.key_name*, which is the name of the key pair that the instance will use for SSH access. The key pair was created by the aws_key_pair resource.
5. The code sets the ```subnet_id``` attribute to *aws_subnet.private_subnet.id*, which is the ID of the subnet that the instance will be launched in. The subnet was created by the aws_subnet resource.
6. The code also sets the ```tags``` attribute to a map of key-value pairs that you can use to label and identify the instance. In this case, the code sets the tag ```Name``` to *Private VM*.
7. The code also uses a provisioner block to run some commands on the instance after it is created. The provisioner type is ```remote-exec```, which means that the commands will be executed remotely via SSH. The provisioner uses the ```inline``` argument to specify a list of commands to run. In this case, the commands are:  
```sudo apt-get update```: This updates the package lists for upgrades and new packages.  
```sudo apt-get install -y nginx```: This installs nginx, a web server, on the instance.  
```sudo systemctl start nginx```: This starts nginx on the instance.  
### Output
![image](https://github.com/ratinderpalsingh516/Terraform_Assignment/assets/122514456/e6b5f52f-7aad-4a7b-8eb3-d0e13d1562d0)

